// Generated by CoffeeScript 1.12.2
(function() {
  var BufferIterator, flags, sampleFlags, tools,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  tools = require('../tools');

  BufferIterator = require('../bufferIterator');

  flags = {
    'dataOffset': 0x01,
    'firstSampleFlags': 0x04,
    'sampleDuration': 0x100,
    'sampleSize': 0x200,
    'sampleFlags': 0x400,
    'sampleCompositionTimeOffset': 0x800
  };

  sampleFlags = ['sampleDuration', 'sampleSize', 'sampleFlags', 'sampleCompositionTimeOffset'];

  module.exports.decode = function(buffer, offset) {
    var data, flag, i, iterator, j, key, ref, sample;
    iterator = new BufferIterator(buffer);
    data = tools.initBoxData(iterator, flags);
    data.sampleCount = iterator.read32();
    if (data.dataOffset) {
      data.dataOffset = iterator.read32();
    }
    if (data.firstSampleFlags) {
      data.firstSampleFlags = iterator.read32();
    }
    data.samples = [];
    for (i = j = 0, ref = data.sampleCount - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      sample = {};
      if (data.sampleDuration) {
        sample.sampleDuration = iterator.read32();
      }
      if (data.sampleSize) {
        sample.sampleSize = iterator.read32();
      }
      if (data.sampleFlags) {
        sample.sampleFlags = iterator.read32();
      }
      if (data.sampleCompositionTimeOffset) {
        sample.sampleCompositionTimeOffset = iterator.read32();
      }
      data.samples.push(sample);
    }
    for (key in flags) {
      flag = flags[key];
      if (indexOf.call(sampleFlags, key) >= 0) {
        delete data[key];
      } else if (!data[key]) {
        delete data[key];
      }
    }
    return data;
  };

  module.exports.encode = function(data) {
    var iterator, j, k, key, l, len, len1, len2, len3, length, m, ref, ref1, sample, sampleLength;
    for (j = 0, len = sampleFlags.length; j < len; j++) {
      key = sampleFlags[j];
      data[key] = false;
    }
    sampleLength = 0;
    ref = data.samples;
    for (k = 0, len1 = ref.length; k < len1; k++) {
      sample = ref[k];
      for (l = 0, len2 = sampleFlags.length; l < len2; l++) {
        key = sampleFlags[l];
        if ((sample[key] != null) && !data[key]) {
          sampleLength += 4;
          data[key] = true;
        }
      }
    }
    length = 4;
    if (data.dataOffset != null) {
      length += 4;
    }
    if (data.firstSampleFlags != null) {
      length += 4;
    }
    iterator = tools.writeBoxData(data, length + sampleLength * data.samples.length, flags);
    iterator.write32(data.samples.length);
    if (data.dataOffset != null) {
      iterator.write32(data.dataOffset);
    }
    if (data.firstSampleFlags != null) {
      iterator.write32(data.firstSampleFlags);
    }
    ref1 = data.samples;
    for (m = 0, len3 = ref1.length; m < len3; m++) {
      sample = ref1[m];
      if (data.sampleDuration) {
        iterator.write32(sample.sampleDuration);
      }
      if (data.sampleSize) {
        iterator.write32(sample.sampleSize);
      }
      if (data.sampleFlags) {
        iterator.write32(sample.sampleFlags);
      }
      if (data.sampleCompositionTimeOffset) {
        iterator.write32(sample.sampleCompositionTimeOffset);
      }
    }
    return iterator.buffer;
  };

}).call(this);
